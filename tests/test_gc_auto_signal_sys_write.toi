from lib.test import assert_true

global string = import string

fn alloc_wave(count)
  for i in 1..count
    s = string.format("item_%d", i)
    t = string.format("%s_tmp", s)
    n = i + 1
    box = {s, t, n}
    pair = {left = box, right = {v = n}}
    box.self = pair

base = mem()
peak = base

for round in 1..80
  alloc_wave(1200)
  now = mem()
  if now > peak
    peak = now

-- Keep some live objects to ensure we do not optimize away all roots.
keep = {}
for i in 1..2000
  keep[i] = {v = i}

after = mem()

-- With automatic GC working, memory should stay bounded under heavy churn.
assert_true(peak <= base + 67108864)
assert_true(after <= base + 67108864)
assert_true(keep[1].v == 1)
assert_true(keep[2000].v == 2000)

from lib.test import assert_true, expect_error

signal = import signal

assert_true(signal.ignore("INT"))
assert_true(signal.raise("INT"))
assert_true(signal.default("INT"))

msg = expect_error(fn() signal.raise("NO_SUCH_SIGNAL"))
assert_true(msg != nil)

print "signal ok"

from lib.test import assert_eq, assert_true

sys = import sys

assert_eq(sys.write("", 1), 0)
bad, err = sys.write("", 3)
assert_true(bad == nil)
assert_eq(type(err), "string")

print "sys.write ok"
