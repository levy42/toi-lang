from lib.test import assert_true

fn churn(count)
  for i in 1..count
    a = i + 1
    b = i + 2
    t = {i, a, b}
    t.self = t
    u = {a = t, b = {v = i}}

base = mem()
churn(20000)
gc
after_churn = mem()

-- Allow some headroom for globals and allocator bookkeeping.
assert_true(after_churn <= base + 262144)

keepers = {}
for i in 1..6000
  nxt = i + 1
  keepers[i] = {v = i, next = {nxt}}

gc
with_live = mem()
assert_true(with_live > after_churn)
assert_true(keepers[1].v == 1)
assert_true(keepers[6000].v == 6000)

keepers = nil
gc
after_drop = mem()
assert_true(after_drop < with_live)

from lib.test import assert_eq, assert_true

stat = import stat
os = import os
io = import io

PATH = "tests/tmp_stat_file.txt"
safe_rm_ok = nil
if os.exists(PATH)
  safe_rm_ok = os.remove(PATH)

f = io.open(PATH, "w")
f.write("hello")
f.close()

st = stat.stat(PATH)
assert_true(st != nil, "stat failed")
assert_eq(type(st), "table")
assert_true(st.is_file == true)
assert_true(st.is_dir == false)
assert_true(st.size >= 5)
assert_true(st.mode > 0)
assert_true(st.mtime > 0)

lst = stat.lstat(PATH)
assert_true(lst != nil, "lstat failed")
assert_true(lst.is_file == true)

ok = stat.chmod(PATH, 384) -- 0600
assert_true(ok == true, "chmod failed")

old = stat.umask()
assert_true(old >= 0)

miss = stat.stat("tests/does_not_exist___stat")
assert_true(type(miss) == "string")

rm_ok = os.remove(PATH)
assert_true(rm_ok == true)

print "stat ok"

from lib.test import assert_true, assert_eq

assert_true(istype(nil, "nil"))
assert_true(istype(true, "boolean"))
assert_true(istype(12.5, "number"))
assert_true(istype("x", "string"))
assert_true(istype({1, 2}, "table"))
f = fn()
  return 1
assert_true(istype(f, "function"))

assert_true(istype("x", "number", "string"))
assert_true(not istype("x", "number", "table"))
assert_true(istype(true, "bool"))
assert_true(istype(12.5, "int"))
assert_true(istype(12.5, "float"))

assert_eq(type("x"), "string")
assert_eq(istype("x", "string"), true)
assert_eq(istype("x", "table"), false)

print "istype ok"
