from lib.test import assert_eq

iter_obj = {
  n = 4
}

fn iter_obj_step(state, control)
  i = control
  if i == nil
    i = 1
  else
    i = i + 1
  if i > state.n
    return nil, nil
  return i, i * 10

iter_obj.__next = iter_obj_step

sum_vals = 0
sum_keys = 0
for k, v in iter_obj
  sum_keys = sum_keys + k
  sum_vals = sum_vals + v
assert_eq(sum_keys, 10)
assert_eq(sum_vals, 100)

next_obj = {
  n = 3
}

fn next_obj_next(self, control)
  i = control
  if i == nil
    i = 1
  else
    i = i + 1
  if i > self.n
    return nil, nil
  return i, i + 1

next_obj.__next = next_obj_next

vals = 0
for v in next_obj
  vals = vals + v
assert_eq(vals, 9)

override = {
  10, 20, 30
}

fn override_step(state, control)
  i = control
  if i == nil
    i = 1
  else
    i = i + 1
  if i > state.n
    return nil, nil
  return i, i

override.n = 3
override.__next = override_step

custom_sum = 0
for v in override
  custom_sum = custom_sum + v
assert_eq(custom_sum, 6)

print "iterators ok"

from lib.test import assert_eq, assert_true

http_server = import lib.http_server
socket = import socket
thread = import thread
string = import string

CERT = "tests/fixtures/tls/server.crt"
KEY = "tests/fixtures/tls/server.key"

fn assert_has(haystack, needle)
  i, j = string.find(haystack, needle)
  if i == nil
    error("assert_has failed: missing '" + needle + "'")

fn starts_with(s, prefix)
  if type(s) != "string"
    return false
  if #s < #prefix
    return false
  return string.sub(s, 1, #prefix) == prefix

fn wait_until_running(app, timeout_sec = 1.0)
  elapsed = 0.0
  while elapsed < timeout_sec
    if app.is_running()
      return true
    thread.sleep(0.01)
    elapsed = elapsed + 0.01
  return app.is_running()

fn find_free_port(start_port = 19443, end_port = 19483)
  probe = socket.tcp()
  if probe == nil
    return "skip:socket.tcp failed"

  port = start_port
  while port <= end_port
    r = probe.bind(probe, "127.0.0.1", port)
    if r == true
      probe.close(probe)
      return port

    msg = string.lower(str(r))
    if string.find(msg, "address already in use") != nil
      port = port + 1
      continue

    if string.find(msg, "operation not permitted") != nil
      probe.close(probe)
      return "skip:" + str(r)

    probe.close(probe)
    return "skip:" + str(r)

  probe.close(probe)
  return "skip:no free loopback port"

if not socket.tls_available()
  print "http server tls skipped (tls unavailable)"
else
  port = find_free_port()
  if starts_with(port, "skip:")
    print "http server tls skipped (" + string.sub(port, 6) + ")"
  else
    assert_true(type(port) == "number", "no free loopback port")

    app = http_server(port=port, host="127.0.0.1", ssl=true, ssl_cert=CERT, ssl_key=KEY)
    get = app.get

    @get("/")
    fn root()
      return "secure hello"

    h, spawn_err = thread.spawn(fn()
      return app.run()
    )
    assert_true(h != nil, "spawn failed")
    assert_true(wait_until_running(app), "server did not start")

    client = socket.tcp()
    assert_true(client != nil)

    connected = client.connect(client, "127.0.0.1", port)
    assert_true(connected == true, "connect failed: " + str(connected))

    tls_ok = client.tls(client, "localhost", false)
    assert_true(tls_ok == true, "client tls failed: " + str(tls_ok))

    sent = client.send(client, "GET / HTTP/1.1\r\nHost: localhost\r\nConnection: close\r\n\r\n")
    assert_true(type(sent) == "number", "send failed: " + str(sent))

    client.settimeout(client, 1)

    response = ""
    i = 1
    while i <= 20
      chunk, recv_err = client.recv(client, 4096)
      if chunk == nil
        if recv_err == "timeout"
          break
        break

      response = response + chunk
      if string.find(response, "secure hello") != nil
        break
      i = i + 1

    client.close(client)

    assert_has(response, "200 OK")
    assert_has(response, "secure hello")
    assert_has(response, "Connection: close")

    assert_true(app.stop(0.2) == true)

    result = thread.join(h)
    assert_eq(result, "stopped")
    assert_true(app.is_running() == false)

    print "http server tls ok"
