from lib.test import assert_eq, assert_true

socket = import socket
thread = import thread
string = import string

CERT = "tests/fixtures/tls/server.crt"
KEY = "tests/fixtures/tls/server.key"

fn starts_with(s, prefix)
  if type(s) != "string"
    return false
  if #s < #prefix
    return false
  return string.sub(s, 1, #prefix) == prefix

fn server_worker(port_ch, result_ch)
  srv = socket.tcp()
  if srv == nil
    port_ch.send(port_ch, "skip:socket.tcp failed")
    return true

  port = 18443
  bound = false
  while port <= 18453
    r = srv.bind(srv, "127.0.0.1", port)
    if r == true
      bound = true
      break

    msg = string.lower(str(r))
    if string.find(msg, "address already in use") != nil
      port = port + 1
      continue

    port_ch.send(port_ch, "skip:" + str(r))
    srv.close(srv)
    return true

  if not bound
    port_ch.send(port_ch, "skip:no free loopback port")
    srv.close(srv)
    return true

  srv.listen(srv, 4)
  port_ch.send(port_ch, port)

  client, ip = srv.accept(srv)
  if client == nil
    result_ch.send(result_ch, "accept failed")
    srv.close(srv)
    return false

  tls_ok = client.tls_server(client, CERT, KEY)
  if tls_ok != true
    result_ch.send(result_ch, "tls_server failed: " + str(tls_ok))
    client.close(client)
    srv.close(srv)
    return false

  msg = client.recv(client, 1024)
  if msg != "ping over tls"
    result_ch.send(result_ch, "server recv mismatch: " + str(msg))
    client.close(client)
    srv.close(srv)
    return false

  sent = client.send(client, "pong over tls")
  if type(sent) != "number"
    result_ch.send(result_ch, "server send failed: " + str(sent))
    client.close(client)
    srv.close(srv)
    return false

  client.close(client)
  srv.close(srv)
  result_ch.send(result_ch, "ok")
  return true

if not socket.tls_available()
  print "socket tls loopback skipped (tls unavailable)"
else
  port_ch = thread.channel(1)
  result_ch = thread.channel(1)

  local h, err = thread.spawn(server_worker, port_ch, result_ch)
  assert_true(h != nil, "spawn failed")

  port_or_skip = port_ch.recv(port_ch)
  if type(port_or_skip) == "string" and starts_with(port_or_skip, "skip:")
    local joined = thread.join(h)
    assert_true(joined == true)
    print "socket tls loopback skipped (" + string.sub(port_or_skip, 6) + ")"
  else
    port = port_or_skip
    assert_true(type(port) == "number")

    client = socket.tcp()
    assert_true(client != nil)

    connected = client.connect(client, "127.0.0.1", port)
    assert_true(connected == true, "connect failed: " + str(connected))

    tls_ok = client.tls(client, "localhost", false)
    assert_true(tls_ok == true, "client tls failed: " + str(tls_ok))

    sent = client.send(client, "ping over tls")
    assert_true(type(sent) == "number", "client send failed: " + str(sent))

    reply = client.recv(client, 1024)
    assert_eq(reply, "pong over tls")

    client.close(client)

    server_result = result_ch.recv(result_ch)
    assert_eq(server_result, "ok")

    joined = thread.join(h)
    assert_true(joined == true)

    print "socket tls loopback ok"
