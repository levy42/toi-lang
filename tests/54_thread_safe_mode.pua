from lib.test import assert_eq, assert_true

thread = import thread

WORKERS = 4
ITER = 200

fn worker_inc(mu, counter, n)
  local j = 1
  while j <= n
    mu.lock(mu)
    counter.n = counter.n + 1
    mu.unlock(mu)
    j = j + 1
  return true

counter = {n = 0}
mu = thread.mutex()
handles = {}

i = 1
while i <= WORKERS
  local h, err = thread.spawn(worker_inc, mu, counter, ITER)
  assert_true(h != nil, "spawn failed")
  handles[i] = h
  i = i + 1

i = 1
while i <= WORKERS
  local ok, err = thread.join(handles[i])
  assert_true(ok == true, "join failed")
  i = i + 1

assert_eq(counter.n, WORKERS * ITER)

fn producer(ch, id, n)
  local j = 1
  while j <= n
    ch.send(ch, id * 100000 + j)
    j = j + 1
  ch.send(ch, "done")
  return n

ch = thread.channel(16)
producers = {}

i = 1
while i <= WORKERS
  local p, err = thread.spawn(producer, ch, i, ITER)
  assert_true(p != nil, "producer spawn failed")
  producers[i] = p
  i = i + 1

done = 0
received = 0
sum = 0

while done < WORKERS
  v = ch.recv(ch)
  if v == "done"
    done = done + 1
  else
    received = received + 1
    sum = sum + v

i = 1
while i <= WORKERS
  local count, err = thread.join(producers[i])
  assert_true(count != nil, "producer join failed")
  assert_eq(count, ITER)
  i = i + 1

assert_eq(received, WORKERS * ITER)

expected = 0
i = 1
while i <= WORKERS
  expected = expected + (ITER * (i * 100000)) + (ITER * (ITER + 1) / 2)
  i = i + 1
assert_eq(sum, expected)

print "thread safe mode ok"
