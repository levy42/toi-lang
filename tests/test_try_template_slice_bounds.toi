from lib.test import assert_eq, assert_true

flag = 0
try
  flag = 1
except e
  flag = 2
assert_eq(flag, 1)

try
  throw "boom"
except e
  assert_eq(e, "boom")

flag = 0
try
  flag = 1
finally
  flag = flag + 10
assert_eq(flag, 11)

flag = 0
try
  throw "boom2"
except e
  flag = 1
finally
  flag = flag + 10
assert_eq(flag, 11)

flag = 0
try
  try
    throw "boom3"
  finally
    flag = 1
except e
  assert_eq(e, "boom3")
  assert_eq(flag, 1)

flag = 0
try
  try
    throw "boom4"
  except e
    throw "boom5"
  finally
    flag = 1
except e
  assert_eq(e, "boom5")
  assert_eq(flag, 1)

matched = false
try
  throw {kind = "io", code = 7}
except e if type(e) == "table" and e.kind == "io" and e.code == 7
  matched = true
assert_true(matched)

forwarded_kind = nil
try
  try
    throw {kind = "other", code = 9}
  except e if type(e) == "table" and e.kind == "io"
    throw "should-not-run"
except ex
  forwarded_kind = ex.kind
assert_eq(forwarded_kind, "other")

from lib.test import assert_eq, assert_true

template = import template
global table = import table

src = "Hello {{ name }}! {% set x = base + 1 %}{% if x > 3 %}ok{% else %}bad{% endif %} {% for v in items %}[{{ v }}]{% endfor %}"
ctx = {
  name = "Toi",
  base = 3,
  items = {"a", "b", "c"}
}

out = template.render(src, ctx)
assert_true(out != nil)
assert_eq(out, "Hello Toi! ok [a][b][c]")

print "template implicit ctx ok"

from lib.test import assert_eq

s = "hello"
i = 1
j = 5

assert_eq(s[1+1..4], "ell")
assert_eq(s[i+1..4], "ell")
assert_eq(s[i*2-1..j-1], "hell")

t = {10, 20, 30, 40, 50}
r1 = t[1+1..4]
assert_eq(#r1, 3)
assert_eq(r1[1], 20)
assert_eq(r1[2], 30)
assert_eq(r1[3], 40)

r2 = t[i+1..4]
assert_eq(#r2, 3)
assert_eq(r2[1], 20)
assert_eq(r2[2], 30)
assert_eq(r2[3], 40)

r3 = t[i*2-1..j-1]
assert_eq(#r3, 4)
assert_eq(r3[1], 10)
assert_eq(r3[2], 20)
assert_eq(r3[3], 30)
assert_eq(r3[4], 40)

print "slice expr bounds ok"
