from lib.test import assert_eq

global g = 1

fn set_global()
  global g = 2

set_global()
assert_eq(g, 2)

from lib.test import assert_eq, assert_true

thread = import thread

WORKERS = 4
ITER = 200

fn worker_inc(mu, counter, n)
  j = 1
  while j <= n
    mu.lock(mu)
    counter.n = counter.n + 1
    mu.unlock(mu)
    j = j + 1
  return true

counter = {n = 0}
mu = thread.mutex()
handles = {}

i = 1
while i <= WORKERS
  h = thread.spawn(worker_inc, mu, counter, ITER)
  assert_true(h != nil, "spawn failed")
  handles[i] = h
  i = i + 1

i = 1
while i <= WORKERS
  ok = thread.join(handles[i])
  assert_true(ok == true, "join failed")
  i = i + 1

assert_eq(counter.n, WORKERS * ITER)

fn producer(ch, id, n)
  j = 1
  while j <= n
    ch.send(ch, id * 100000 + j)
    j = j + 1
  ch.send(ch, "done")
  return n

ch = thread.channel(16)
producers = {}

i = 1
while i <= WORKERS
  p = thread.spawn(producer, ch, i, ITER)
  assert_true(p != nil, "producer spawn failed")
  producers[i] = p
  i = i + 1

done = 0
received = 0
sum = 0

while done < WORKERS
  v = ch.recv(ch)
  if v == "done"
    done = done + 1
  else
    received = received + 1
    sum = sum + v

i = 1
while i <= WORKERS
  count = thread.join(producers[i])
  assert_true(count != nil, "producer join failed")
  assert_eq(count, ITER)
  i = i + 1

assert_eq(received, WORKERS * ITER)

expected = 0
i = 1
while i <= WORKERS
  expected = expected + (ITER * (i * 100000)) + (ITER * (ITER + 1) / 2)
  i = i + 1
assert_eq(sum, expected)

print "thread safe mode ok"

from lib.test import assert_eq

assert_eq(sum(x for x in 1..5), 15)
assert_eq(sum((x for x in 1..5)), 15)
assert_eq(sum(x * 2 for x in 1..5 if x > 2), 24)

g = (x * x for x in 1..4)
g2 = (x * x for x in 1..4)
assert_eq(type(g), "generator")
assert_eq(type(g2), "generator")
out = {}
for v in g
  out <+ v
assert_eq(#out, 4)
assert_eq(out[1], 1)
assert_eq(out[4], 16)

out2 = {}
for v in g2
  out2 <+ v
assert_eq(#out2, 4)
assert_eq(out2[1], 1)
assert_eq(out2[4], 16)

print "generator comprehension ok"
