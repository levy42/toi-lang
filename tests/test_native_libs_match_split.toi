from lib.test import assert_eq, assert_true

time = import time
math = import math
string = import string
io = import io
os = import os
table = import table
inspect = import inspect

-- time
secs = time.seconds()
nanos = time.nanos()
assert_true(type(secs) == "number")
assert_true(type(nanos) == "number")
assert_true(nanos > 1000000000)

-- math
assert_eq(math.abs(-3), 3)
assert_eq(math.floor(1.9), 1)
assert_eq(math.sum(1, 2, 3), 6)
assert_eq(math.sum({1, 2, 3, 4}), 10)

-- string module
assert_eq(string.len("abc"), 3)
assert_eq(string.upper("ab"), "AB")
assert_eq(string.sub("hello", 2, 4), "ell")

-- io userdata __index (function)
f = io.open("tests/tmp_io.txt", "w")
f.write("line1\nline2\nXYZ")
f.close()

r = io.open("tests/tmp_io.txt", "r")
line = r.readline()
assert_eq(line, "line1")
chunk = r.read(2)
assert_eq(chunk, "li")
r.close()

r_all = io.open("tests/tmp_io.txt", "r")
all = r_all.read()
assert_eq(all, "line1\nline2\nXYZ")
r_all.close()

-- io seek/tell
s = io.open("tests/tmp_io.txt", "r")
assert_eq(s.tell(), 0)
assert_eq(s.seek("end", 0), 15)
assert_eq(s.tell(), 15)
assert_eq(s.seek("set", 6), 6)
assert_eq(s.read(5), "line2")
assert_eq(s.seek("cur", -5), 6)
assert_eq(s.read(5), "line2")
assert_eq(s.seek(0), 0)
assert_eq(s.read(5), "line1")
s.close()

-- io buffer (in-memory file-like object)
buf = io.buffer("aa\nbb\ncc")
assert_eq(buf.readline(), "aa")
assert_eq(buf.tell(), 3)
assert_eq(buf.read(2), "bb")
assert_eq(buf.seek("set", 0), 0)
assert_eq(buf.read(), "aa\nbb\ncc")
assert_eq(buf.seek("end", 0), 8)
buf.write("DD")
assert_eq(buf.tell(), 10)
assert_eq(buf.seek("set", 8), 8)
assert_eq(buf.read(), "DD")
buf.close()

os.remove("tests/tmp_io.txt")

-- table module
joined = table.concat({"a", "b", "c"}, "-")
assert_eq(joined, "a-b-c")
assert_eq(table.find_index({"a", "b", "c"}, "b"), 2)
assert_eq(table.find_index({"a", "b", "c"}, "x"), 0)
assert_eq(table.find_index({"a", "b", "c", "b"}, "b", 3), 4)
conn_like = {
  {sock = "s1"},
  {sock = "s2"},
  {sock = "s3"}
}
assert_eq(table.find_index(conn_like, "s2", fn(c) return c.sock), 2)
assert_eq(table.find_index(conn_like, "s3", 2, fn(c) return c.sock), 3)

-- inspect module
fn api_handler(user_id: int, q: string = "x", *rest: table)
  return nil

sig = inspect.signature(api_handler)
assert_eq(sig.kind, "function")
assert_eq(sig.arity, 3)
assert_true(sig.variadic)
assert_eq(sig.defaults_count, 1)
assert_eq(sig.params[1].name, "user_id")
assert_eq(sig.params[1].type, "int")
assert_true(sig.params[1].has_default == false)
assert_eq(sig.params[2].name, "q")
assert_eq(sig.params[2].type, "str")
assert_true(sig.params[2].has_default)
assert_eq(sig.params[3].name, "rest")
assert_eq(sig.params[3].type, "table")
assert_true(sig.params[3].variadic)

print "native libs ok"

from lib.test import assert_eq, assert_true

fn classify(n)
  match n
    case 0
      return "zero"
    case 1
      return "one"
    else
      return "many"

assert_eq(classify(0), "zero")
assert_eq(classify(1), "one")
assert_eq(classify(9), "many")

value = "b"
result = ""
match value
  case "a"
    result = "A"
  case "b"
    result = "B"
  else
    result = "?"
assert_eq(result, "B")

count = 0
fn next_value()
  count = count + 1
  return 2

match next_value()
  case 1
    result = "one"
  case 2
    result = "two"
  else
    result = "other"
assert_eq(result, "two")
assert_true(count > 0)
assert_true(not (count > 1))

print "match/case ok"

from lib.test import assert_eq

s = "alpha beta gamma"
parts = s.split()
assert_eq(#parts, 3)
assert_eq(parts[1], "alpha")
assert_eq(parts[3], "gamma")

limit_parts = s.split(" ", 1)
assert_eq(#limit_parts, 2)
assert_eq(limit_parts[1], "alpha")
assert_eq(limit_parts[2], "beta gamma")

reverse_once = s.split(" ", -1)
assert_eq(#reverse_once, 2)
assert_eq(reverse_once[1], "alpha beta")
assert_eq(reverse_once[2], "gamma")

reverse_twice = s.split(" ", -2)
assert_eq(#reverse_twice, 3)
assert_eq(reverse_twice[1], "alpha")
assert_eq(reverse_twice[2], "beta")
assert_eq(reverse_twice[3], "gamma")
