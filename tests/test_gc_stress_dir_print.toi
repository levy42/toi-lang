from lib.test import assert_true

fn alloc_round(count)
  for i in 1..count
    n = i + 1
    a = {i, n}
    b = {left = a, right = {v = i}}
    a.back = b

start = mem()

for round in 1..40
  alloc_round(1200)
  gc

after = mem()
assert_true(after <= start + 393216)

root = {}
for i in 1..3000
  root[i] = {v = i}

for i in 1..5
  gc

assert_true(root[1].v == 1)
assert_true(root[3000].v == 3000)

root = nil
gc

from lib.test import assert_eq, assert_true

dir = import dir
os = import os
io = import io

ROOT = "tests/tmp_dir_case"

fn safe_rm(path)
  if os.exists(path)
    os.remove(path)

fn safe_rmdir(path)
  if os.exists(path) and os.isdir(path)
    os.rmdir(path)

safe_rm(ROOT + "/a.txt")
safe_rm(ROOT + "/b.log")
safe_rmdir(ROOT + "/sub")
safe_rmdir(ROOT)

ok = os.mkdir(ROOT)
assert_true(ok == true)
ok2 = os.mkdir(ROOT + "/sub")
assert_true(ok2 == true)

f = io.open(ROOT + "/a.txt", "w")
f.write("a")
f.close()

f = io.open(ROOT + "/b.log", "w")
f.write("b")
f.close()

names = dir.list(ROOT)
assert_true(names != nil, "dir.list failed")
found_a = false
found_b = false
found_sub = false
for n in names
  if n == "a.txt"
    found_a = true
  if n == "b.log"
    found_b = true
  if n == "sub"
    found_sub = true
assert_true(found_a)
assert_true(found_b)
assert_true(found_sub)

rows = dir.scandir(ROOT)
assert_true(rows != nil, "dir.scandir failed")
has_row = false
for r in rows
  if r.name == "a.txt"
    has_row = true
    assert_eq(r.path, ROOT + "/a.txt")
    assert_true(type(r.type) == "string")
assert_true(has_row)

none = dir.list("tests/does_not_exist___dir")
assert_true(type(none) == "string")

safe_rm(ROOT + "/a.txt")
safe_rm(ROOT + "/b.log")
safe_rmdir(ROOT + "/sub")
safe_rmdir(ROOT)

print "dir ok"

from lib.test import assert_eq

count = 0
fn tick(v)
  count += 1
  return v

print tick("a"), tick("b")
print(tick("c"), tick("d"))
print()

assert_eq(count, 4)
print "print variadic ok"
