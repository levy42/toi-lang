from lib.test import assert_eq, assert_true

btree = import btree
os = import os

-- Best effort cleanup from previous runs.
os.remove("tests/tmp_btree.db")

-- in-memory mode (no path)
mem = btree.open()
mem.put("k", "v")
assert_eq(mem.get("k"), "v")
assert_true(mem.delete("k"))
assert_true(mem.get("k") == nil)
mem.close()

db = btree.open("tests/tmp_btree.db")

-- basic string key/value
db.put("name", "toi")
assert_eq(db.get("name"), "toi")

-- numeric keys and values
db.put(1, "one")
db.put(2, 200)
assert_eq(db.get(1), "one")
assert_eq(db.get(2), 200)

-- overwrite existing key
db.put("name", "toi2")
assert_eq(db.get("name"), "toi2")

-- force splits with many inserts
i = 3
while i <= 600
  db.put(i, i * 10)
  i = i + 1

assert_eq(db.get(80), 800)
assert_eq(db.get(600), 6000)
assert_true(db.get("missing") == nil)


-- inclusive range query on numeric keys
num_rows = db.range(80, 84)
assert_eq(#num_rows, 5)
assert_eq(num_rows[1].key, 80)
assert_eq(num_rows[1].value, 800)
assert_eq(num_rows[5].key, 84)
assert_eq(num_rows[5].value, 840)

-- range query with native limit
num_rows_limited = db.range(80, 84, 2)
assert_eq(#num_rows_limited, 2)
assert_eq(num_rows_limited[1].key, 80)
assert_eq(num_rows_limited[2].key, 81)

assert_eq(#db.range(80, 84, 0), 0)

-- range query with open bounds
prefix_rows = db.range("name", nil)
assert_true(#prefix_rows >= 1)
assert_eq(prefix_rows[1].key, "name")
assert_eq(prefix_rows[1].value, "toi2")

assert_true(db.delete("name"))
assert_true(db.get("name") == nil)
db.put("name", "toi3")
assert_eq(db.get("name"), "toi3")

db.close()

-- reopen and verify persistence
db2 = btree.open("tests/tmp_btree.db")
assert_eq(db2.get("name"), "toi3")
assert_eq(db2.get(1), "one")
assert_eq(db2.get(80), 800)
assert_eq(db2.get(600), 6000)
assert_true(db2.get(9999) == nil)

assert_true(db2.delete(1))
assert_true(db2.get(1) == nil)
assert_true(db2.delete(424242) == false)
db2.close()

db3 = btree.open("tests/tmp_btree.db")
assert_true(db3.get(1) == nil)
assert_eq(db3.get("name"), "toi3")
db3.close()

os.remove("tests/tmp_btree.db")

print "btree ok"

from lib.test import assert_eq, assert_true

http_server = import lib.http_server

fn assert_has(haystack, needle)
  i, j = string.find(haystack, needle)
  if i == nil
    error("assert_has failed: missing '" + needle + "'")

string = import string
global coroutine = import coroutine

fn chunk_gen()
  yield "a"
  yield "b"
  yield "c"

app = http_server(port=0, host="127.0.0.1")
get = app.get

@get("/stream1")
fn stream1()
  return chunk_gen()

@get("/stream2")
fn stream2()
  return {status = 201, headers = {["X-Test"] = "1"}, stream = chunk_gen()}

@get("/stream3")
fn stream3()
  return {status = 202, body = chunk_gen()}

r1 = app.handler({method = "GET", path = "/stream1"})
assert_true(type(r1) == "table")
assert_true(r1.__stream == true)
assert_true(type(r1.stream) == "generator")

v1 = coroutine.resume(r1.stream)
v2 = coroutine.resume(r1.stream)
v3 = coroutine.resume(r1.stream)
assert_eq(v1, "a")
assert_eq(v2, "b")
assert_eq(v3, "c")

r2 = app.handler({method = "GET", path = "/stream2"})
assert_true(type(r2) == "table")
assert_true(r2.__stream == true)
assert_eq(r2.status, 201)
assert_eq(r2.headers["X-Test"], "1")

r3 = app.handler({method = "GET", path = "/stream3"})
assert_true(type(r3) == "table")
assert_true(r3.__stream == true)
assert_eq(r3.status, 202)

print "http streaming generators ok"
