import io, os, string, table

TRACE = 10
DEBUG = 20
INFO = 30
WARN = 40
ERROR = 50
FATAL = 60
DEFAULT_LEVEL = INFO

LEVEL_NAMES = {
  [10] = "TRACE",
  [20] = "DEBUG",
  [30] = "INFO",
  [40] = "WARN",
  [50] = "ERROR"
}

ESC = string.char(27)
ANSI_RESET = ESC + "[0m"
LEVEL_COLORS = {
  [10] = ESC + "[36m", -- cyan
  [20] = ESC + "[34m", -- blue
  [30] = ESC + "[32m", -- green
  [40] = ESC + "[33m", -- yellow
  [50] = ESC + "[31m"  -- red
}

fn parse_level(level)
  if type(level) == "number"
    return int(level)
  if type(level) != "string"
    return DEFAULT_LEVEL
  token = string.lower(string.trim(level))
  if token == "trace"
    return TRACE
  if token == "debug"
    return DEBUG
  if token == "info"
    return INFO
  if token == "warn" or token == "warning"
    return WARN
  if token == "error"
    return ERROR
  if token == "fatal"
    return FATAL
  return DEFAULT_LEVEL

fn level_name(level)
  return LEVEL_NAMES[parse_level(level)] or "INFO"

fn fmt_fields(fields)
  if not istype(fields, 'table') return ""
  parts = {}
  for k, v in fields
    parts <+ f"{k}={v}"
  if #parts == 0 return ""
  return " " + table.concat(parts, " ")

fn default_formatter(record)
  ts = int(record.ts or 0)
  lvl = LEVEL_NAMES[record.level]
  logger_name = record.logger or "root"
  msg = str(record.msg or "")
  return string.format("%d %-5s [%s] %s%s", ts, lvl, logger_name, msg, fmt_fields(record.fields))

fn colorize_line(line, level)
  if os.getenv("NO_COLOR") or not os.getenv("TERM")
    return line

  color = LEVEL_COLORS[level]
  lvl = LEVEL_NAMES[level]
  i, j = line.find(lvl)
  if i == nil
    return color + line + ANSI_RESET
  return line[1..i-1] + color + lvl + ANSI_RESET + line[j+1..]

fn console_handler(record, line)
  print(colorize_line(line, record.level))
  return true

fn file_handler(path, append = true)
  assert path and istype(path, 'string'), "file_handler(path): path must be a non-empty string"
  mode = append ? "a" : "w"
  file = io.open(path, mode)
  return fn(record, line)
    file.write(line + "\n")
    return true

Logger = {}
Logger.__index = Logger

fn logger_new(cls, name = "root", opts = nil)
  if opts == nil opts = {}
  obj = {}
  obj.name = name
  obj.level = parse_level(opts.level or DEFAULT_LEVEL)
  obj.handlers = {}
  obj.formatter = opts.formatter or default_formatter
  obj.context = opts.context

  for h in (opts.handlers or {})
    obj.handlers <+ h
  if not obj.handlers
    obj.handlers <+ console_handler

  setmetatable(obj, cls)
  return obj

LoggerMeta = {}
LoggerMeta.__call = logger_new
setmetatable(Logger, LoggerMeta)

Logger.set_level = fn(self, level)
  self.level = parse_level(level)
  return self

Logger.is_enabled = fn(self, level)
  return (level or DEFAULT_LEVEL) >= self.level

Logger.add_handler = fn(self, handler)
  if type(handler) == "function"
    self.handlers <+ handler
  return self

Logger.clear_handlers = fn(self)
  self.handlers = {}
  return self

fn spawn_child_logger(self, child_name, fields = nil)
  return Logger(child_name, {
    level = self.level,
    handlers = self.handlers,
    formatter = self.formatter,
    context = self.context + fields
  })

Logger.with_fields = fn(self, fields)
  return spawn_child_logger(self, self.name, fields)

Logger.child = fn(self, suffix, fields = nil)
  child_name = self.name
  if type(suffix) == "string" and suffix != ""
    child_name = self.name + "." + suffix
  return spawn_child_logger(self, child_name, fields)

Logger.log = fn(self, level:int, msg:str, fields = nil)
  if level < self.level
    return false

  record = {
    ts = int(os.clock()),
    level = level,
    logger = self.name,
    msg = msg,
    fields = fields? (self.context + fields): self.context
  }
  line = self.formatter(record)

  for h in self.handlers
    try
      h(record, line)
    except e
      nil
  return true

Logger.trace = fn(self, msg, fields = nil)
  return self.log(TRACE, msg, fields)

Logger.debug = fn(self, msg, fields = nil)
  return self.log(DEBUG, msg, fields)

Logger.info = fn(self, msg, fields = nil)
  return self.log(INFO, msg, fields)

Logger.warn = fn(self, msg, fields = nil)
  return self.log(WARN, msg, fields)

Logger.error = fn(self, msg, fields = nil)
  return self.log(ERROR, msg, fields)

_registry = {}
_root = Logger("root")
_registry["root"] = _root

fn get_logger(name:str = "root")
  if _registry[name] return _registry[name]
  logger = Logger(name)
  _registry[name] = logger
  return logger

fn configure(level = nil, handlers = nil, formatter = nil, context = nil)
  if level != nil _root.set_level(parse_level(level))
  if formatter
    _root.formatter = formatter
  if context
    _root.context = context
  if handlers
    _root.handlers = {}
    if handlers
      for h in handlers
        _root.handlers <+ h
    elif not _root.handlers
      _root.handlers <+ console_handler
  return _root

fn log(level, msg, fields = nil)
  return _root.log(level, msg, fields)

fn trace(msg, fields = nil)
  return _root.trace(msg, fields)

fn debug(msg, fields = nil)
  return _root.debug(msg, fields)

fn info(msg, fields = nil)
  return _root.info(msg, fields)

fn warn(msg, fields = nil)
  return _root.warn(msg, fields)

fn error_(msg, fields = nil)
  return _root.error(msg, fields)

return {
  parse_level = parse_level,
  level_name = level_name,
  default_formatter = default_formatter,
  console_handler = console_handler,
  file_handler = file_handler,
  Logger = Logger,
  get_logger = get_logger,
  configure = configure,
  root = _root,
  log = log,trace = trace, debug = debug, info = info, warn = warn, error = error_,
  DEBUG = DEBUG, ERROR = ERROR, TRACE = TRACE, INFO = INFO, WARN = WARN,
}
