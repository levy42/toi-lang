string = import string
table = import table

fn starts_with(s, prefix)
  if #prefix == 0 return true
  if #s < #prefix return false
  return s[1..#prefix] == prefix

fn escape_html(text)
  if not text return ""
  out = {}
  for ch in text
    if ch == "&"
      out[#out + 1] = "&amp;"
    elif ch == "<"
      out[#out + 1] = "&lt;"
    elif ch == ">"
      out[#out + 1] = "&gt;"
    elif ch == '"'
      out[#out + 1] = "&quot;"
    elif ch == "'"
      out[#out + 1] = "&#39;"
    else
      out[#out + 1] = ch
  return table.concat(out, "")

fn find_token(text, token, start)
  i, j = string.find(text, token, start)
  return i, j

fn parse_inline(text)
  if not text return ""

  out = {}
  i = 1
  while i <= #text
    ch = text[i]

    if ch == "`"
      close_i, close_j = find_token(text, "`", i + 1)
      if close_i
        code = string.sub(text, i + 1, close_i - 1)
        out[#out + 1] = "<code>" + escape_html(code) + "</code>"
        i = close_j + 1
        continue

    if ch == "*" and i < #text and text[i + 1] == "*"
      close_i, close_j = find_token(text, "**", i + 2)
      if close_i
        inner = string.sub(text, i + 2, close_i - 1)
        out[#out + 1] = "<strong>" + parse_inline(inner) + "</strong>"
        i = close_j + 1
        continue

    if ch == "*"
      close_i, close_j = find_token(text, "*", i + 1)
      if close_i
        inner = string.sub(text, i + 1, close_i - 1)
        out[#out + 1] = "<em>" + parse_inline(inner) + "</em>"
        i = close_j + 1
        continue

    out[#out + 1] = escape_html(ch)
    i = i + 1

  return table.concat(out, "")

fn flush_paragraph(out, paragraph_lines)
  if #paragraph_lines == 0
    return nil
  s = parse_inline(table.concat(paragraph_lines, " "))
  out[#out + 1] = "<p>" + s + "</p>"

  while #paragraph_lines > 0
    paragraph_lines[-1] = nil

fn flush_code_block(out, code_lines, code_lang)
  class_attr = ""
  if code_lang and #code_lang > 0
    class_attr = " class=\"language-" + escape_html(code_lang) + "\""
  code = escape_html(table.concat(code_lines, "\n"))
  out[#out + 1] = "<pre><code" + class_attr + ">" + code + "</code></pre>"

  while #code_lines > 0
    code_lines[-1] = nil

fn to_html(markdown)
  if not markdown return ""
  if type(markdown) != "string"
    markdown = str(markdown)

  lines = string.split(markdown, "\n")
  out = {}
  paragraph_lines = {}
  code_lines = {}

  in_code_block = false
  code_lang = nil

  for line in lines
    if #line > 0 and line[#line] == "\r"
      line = string.sub(line, 1, #line - 1)

    if in_code_block
      if starts_with(line, "```")
        flush_code_block(out, code_lines, code_lang)
        in_code_block = false
        code_lang = nil
      else
        code_lines[#code_lines + 1] = line
      continue

    if starts_with(line, "```")
      flush_paragraph(out, paragraph_lines)
      in_code_block = true
      code_lang = string.trim(line[4..])
      continue

    if string.trim(line) == ""
      flush_paragraph(out, paragraph_lines)
      continue

    paragraph_lines[#paragraph_lines + 1] = line

  flush_paragraph(out, paragraph_lines)

  if in_code_block
    flush_code_block(out, code_lines, code_lang)

  return table.concat(out, "\n")

return {
  to_html = to_html,
  parse = to_html,
}
