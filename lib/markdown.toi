import string, cli.pigment, regex

fn append_escaped_char(out, ch)
  out <+ string.escape_html(ch)

fn clear(values)
  while #values > 0
    values[#values] = nil

fn rewrite_link_href(href)
  if not href
    return href
  if href.starts_with("#") or href.find("://") or href.lower().starts_with("mailto:")
    return href

  base, frag = href.split('#')
  if frag and #frag > 0
    frag = "#" + frag
  else
    frag = ""

  if base.lower().ends_with('.md')
    base = base[..-3] + ".html"

  return base + frag

fn heading_slug(text)
  slug = regex.replace('[^a-z0-9]+', '-', text.lower())
  slug = slug.trim('-')
  return slug or "section"

fn parse_inline(text)
  if not text
    return ""

  out = {}
  i = 1
  while i <= #text
    ch = text[i]
    handled = false

    if ch == "`"
      j = i + 1
      while j <= #text and text[j] != "`"
        j += 1
      if j <= #text
        out <+ "<code>"
        k = i + 1
        while k < j
          append_escaped_char(out, text[k])
          k += 1
        out <+ "</code>"
        i = j + 1
        handled = true

    if not handled and ch == "*" and i < #text and text[i + 1] == "*"
      j = i + 2
      while j < #text
        if text[j] == "*" and text[j + 1] == "*"
          break
        j += 1
      if j < #text
        out <+ "<strong>"
        k = i + 2
        while k < j
          append_escaped_char(out, text[k])
          k += 1
        out <+ "</strong>"
        i = j + 2
        handled = true

    if not handled and ch == "*"
      j = i + 1
      while j <= #text and text[j] != "*"
        j += 1
      if j <= #text
        out <+ "<em>"
        k = i + 1
        while k < j
          append_escaped_char(out, text[k])
          k += 1
        out <+ "</em>"
        i = j + 1
        handled = true

    if not handled and ch == "["
      j = i + 1
      while j <= #text and text[j] != "]"
        j = j + 1
      if j <= #text and j + 2 <= #text and text[j + 1] == "("
        k = j + 2
        while k <= #text and text[k] != ")"
          k = k + 1
        if k <= #text
          label = text[i + 1..j - 1]
          href = rewrite_link_href(text[j + 2..k - 1])
          html_label = parse_inline(label)
          out <+ f"<a href=\"{string.escape_html(href)}\">{html_label}</a>"
          i = k + 1
          handled = true

    if not handled
      append_escaped_char(out, ch)
      i = i + 1

  return "".join(out)

fn flush_paragraph(out, paragraph_lines)
  if #paragraph_lines == 0
    return nil
  s = parse_inline(" ".join(paragraph_lines))
  out <+ f"<p>{s}</p>"
  clear(paragraph_lines)

fn flush_code_block(out, code_lines, code_lang)
  class_attr = ""
  if code_lang and #code_lang > 0
    class_attr = f" class=\"language-{string.escape_html(code_lang)}\""
  normalized_lines = {}
  for line in code_lines
    normalized_lines <+ str(line)
  raw_code = "\n".join(normalized_lines)
  while #raw_code > 0 and raw_code.ends_with("\n")
    raw_code = raw_code[..-1]
  code = string.escape_html(raw_code)
  if pigment and code_lang and #code_lang > 0
    code = pigment.highlight(raw_code, code_lang)
  out <+ f"<pre><code{class_attr}>{code}</code></pre>"
  clear(code_lines)

fn flush_blockquote(out, quote_lines)
  if #quote_lines == 0
    return nil
  s = parse_inline(" ".join(quote_lines))
  out <+ "<blockquote>"
  out <+ f"<p>{s}</p>"
  out <+ "</blockquote>"
  clear(quote_lines)

fn is_horizontal_rule(line)
  s = line.trim()
  if #s < 3
    return false
  ch = s[1]
  if ch != "-" and ch != "*" and ch != "_"
    return false
  count = 0
  for c in s
    if c != ch and c != " "
      return false
    if c == ch
      count = count + 1
  return count >= 3

fn parse_heading(line)
  s = line.ltrim()
  if not s
    return nil

  i = 1
  while i <= #s and s[i] == "#"
    i += 1
  count = i - 1
  if count < 1 or count > 6
    return nil
  if i > #s or s[i] != " "
    return nil
  text_start = i + 1
  text = s[text_start..].trim()
  return {level = count, text = text}

fn parse_unordered_item(line)
  s = line.ltrim()
  if #s < 2
    return nil
  marker = s[1]
  if not ({'-', '*', '+'} has marker)
    return nil
  if s[2] != " "
    return nil
  return s[3..].trim()

fn parse_ordered_item(line)
  s = line.ltrim()
  if not s
    return nil
  i = 1
  while i <= #s and s[i].is_digit()
    i = i + 1
  if i == 1
    return nil
  if i + 1 > #s
    return nil
  if s[i] != "." or s[i + 1] != " "
    return nil
  text_start = i + 2
  return s[text_start..].trim()

fn leading_indent(line)
  if not line
    return 0
  col = 0
  idx = 1
  while idx <= #line
    ch = line[idx]
    if ch == " "
      col = col + 1
    elif ch == "\t"
      col = col + 2
    else
      break
    idx = idx + 1
  return col

fn parse_list_item(line)
  ul = parse_unordered_item(line)
  if ul
    return {kind = "ul", indent = leading_indent(line), text = ul}
  ol = parse_ordered_item(line)
  if ol
    return {kind = "ol", indent = leading_indent(line), text = ol}
  return nil

fn close_list_stack(out, stack)
  while #stack > 0
    top = stack[#stack]
    if top.li_open
      out <+ "</li>"
    out <+ f"</{top.kind}>"
    stack[#stack] = nil

fn emit_list_item(out, stack, item)
  while #stack > 0 and item.indent < stack[#stack].indent
    top = stack[#stack]
    if top.li_open
      out <+ "</li>"
    out <+ f"</{top.kind}>"
    stack[#stack] = nil

  while #stack > 0 and item.indent == stack[#stack].indent and item.kind != stack[#stack].kind
    top = stack[#stack]
    if top.li_open
      out <+ "</li>"
    out <+ f"</{top.kind}>"
    stack[#stack] = nil

  if #stack == 0
    out <+ f"<{item.kind}>"
    stack <+ {kind = item.kind, indent = item.indent, li_open = false}
  elif item.indent > stack[#stack].indent
    out <+ f"<{item.kind}>"
    stack <+ {kind = item.kind, indent = item.indent, li_open = false}

  top = stack[#stack]
  if top.li_open
    out <+ "</li>"
  text = parse_inline(item.text)
  out <+ f"<li>{text}"
  top.li_open = true
  stack[#stack] = top

fn split_table_cells(line)
  raw = line.trim()
  if not raw
    return {}
  if raw.starts_with("|")
    raw = raw[2..]
  if #raw > 0 and raw.ends_with("|")
    raw = raw[..-1]
  return {p.trim() for p in raw.split("|")}

fn is_table_candidate(line)
  if not line
    return false
  s = line.trim()
  return s.find("|") != nil

fn is_table_separator_line(line)
  cells = split_table_cells(line)
  if not cells
    return false
  for cell in cells
    token = cell.trim()
    if not token
      return false
    dashes = 0
    idx = 1
    while idx <= #token
      ch = token[idx]
      if ch != "-" and ch != ":" and ch != " "
        return false
      if ch == "-"
        dashes = dashes + 1
      idx = idx + 1
    if dashes < 3
      return false
  return true

fn to_html(markdown)
  lines = markdown.split("\n")
  out = {}
  paragraph_lines = {}
  code_lines = {}
  quote_lines = {}
  list_stack = {}

  in_code_block = false
  code_lang = nil
  pending_table_header = nil
  in_table = false

  for line in lines
    if line and line.ends_with("\r")
      line = line[..-1]

    if in_code_block
      if line.starts_with("```")
        flush_code_block(out, code_lines, code_lang)
        in_code_block = false
        code_lang = nil
      else
        code_lines <+ line
      continue

    if line.starts_with("```")
      flush_paragraph(out, paragraph_lines)
      flush_blockquote(out, quote_lines)
      close_list_stack(out, list_stack)
      if in_table
        out <+ "</tbody></table>"
        in_table = false
      pending_table_header = nil
      in_code_block = true
      code_lang = line[4..].trim()
      continue

    if in_table
      if is_table_candidate(line)
        cells = split_table_cells(line)
        out <+ "<tr>"
        out += {f"<td>{parse_inline(c)}</td>" for c in cells}
        out <+ "</tr>"
        continue
      out <+ "</tbody></table>"
      in_table = false

    if pending_table_header
      if is_table_separator_line(line)
        flush_paragraph(out, paragraph_lines)
        flush_blockquote(out, quote_lines)
        close_list_stack(out, list_stack)
        headers = split_table_cells(pending_table_header)
        out <+ "<table><thead><tr>"
        out += {f"<th>{parse_inline(h)}</th>" for h in headers}
        out <+ "</tr></thead><tbody>"
        pending_table_header = nil
        in_table = true
        continue
      paragraph_lines <+ pending_table_header
      pending_table_header = nil

    if line.trim() == ""
      flush_paragraph(out, paragraph_lines)
      flush_blockquote(out, quote_lines)
      close_list_stack(out, list_stack)
      continue

    trimmed = line.ltrim()
    if trimmed.starts_with(">")
      flush_paragraph(out, paragraph_lines)
      close_list_stack(out, list_stack)
      q = trimmed[2..]
      if q.starts_with(" ")
        q = q[2..]
      quote_lines <+ q
      continue
    else
      flush_blockquote(out, quote_lines)

    if is_horizontal_rule(line)
      flush_paragraph(out, paragraph_lines)
      close_list_stack(out, list_stack)
      out <+ "<hr />"
      continue

    heading = parse_heading(line)
    if heading
      flush_paragraph(out, paragraph_lines)
      close_list_stack(out, list_stack)
      id = heading_slug(heading.text)
      level = str(heading.level)
      text = parse_inline(heading.text)
      out <+ f"<h{level} id=\"{string.escape_html(id)}\">{text}</h{level}>"
      continue

    item = parse_list_item(line)
    if item
      flush_paragraph(out, paragraph_lines)
      flush_blockquote(out, quote_lines)
      emit_list_item(out, list_stack, item)
      continue

    if is_table_candidate(line)
      flush_paragraph(out, paragraph_lines)
      flush_blockquote(out, quote_lines)
      close_list_stack(out, list_stack)
      pending_table_header = line
      continue

    close_list_stack(out, list_stack)
    paragraph_lines <+ line

  if pending_table_header
    paragraph_lines <+ pending_table_header

  flush_paragraph(out, paragraph_lines)
  flush_blockquote(out, quote_lines)
  close_list_stack(out, list_stack)

  if in_table
    out <+ "</tbody></table>"

  if in_code_block
    flush_code_block(out, code_lines, code_lang)

  return "\n".join(out)

return {
  to_html = to_html,
  parse = to_html,
}
