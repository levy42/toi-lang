inspect = import inspect
io = import io
os = import os
string = import string
table = import table
types = import lib.types
thread = nil
try
  thread = import thread
except e
  thread = nil

ESC = string.char(27)
ANSI = {
  reset = ESC + "[0m",
  black = ESC + "[30m",
  red = ESC + "[31m",
  green = ESC + "[32m",
  yellow = ESC + "[33m",
  blue = ESC + "[34m",
  magenta = ESC + "[35m",
  cyan = ESC + "[36m",
  white = ESC + "[37m",
  bold = ESC + "[1m",
  dim = ESC + "[2m",
  underline = ESC + "[4m"
}

fn _tag_code(tag)
  if tag == "/" or tag == "reset"
    return ANSI.reset
  codes = {}
  token = ""
  i = 1
  for ch in tag
    if ch == "+" or ch == "," or ch == "|" or ch == " "
      if #token > 0
        code = ANSI[token]
        if code == nil return nil
        codes[#codes + 1] = code
        token = ""
    else
      token = token + ch

  if #token > 0
    code = ANSI[token]
    if code == nil return nil
    codes[#codes + 1] = code

  if #codes == 0
    return nil
  return table.concat(codes, "")

fn _format(text)
  if text == nil return ""
  if type(text) != "string"
    text = str(text)

  out = {}
  used_color = false
  i = 1
  while i <= #text
    consumed = false
    c = text[i]
    if c == "["
      -- Escape: [[ => literal [
      if i < #text and text[i + 1] == "["
        out[#out + 1] = "["
        i = i + 1
        consumed = true

      close_i = string.find(text, "]", i + 1)
      if close_i != nil and close_i > i
        tag = string.sub(text, i + 1, close_i - 1)
        code = _tag_code(tag)
        if code != nil
          out[#out + 1] = code
          used_color = true
          i = close_i
          consumed = true

    if not consumed
      out[#out + 1] = c
    i = i + 1

  if used_color
    out[#out + 1] = ANSI.reset
  return table.concat(out, "")

fn printc(text)
  print _format(text)

_stdout_file = nil
_stdout_failed = false

fn _stdout()
  if _stdout_failed
    return nil
  if _stdout_file == nil
    try
      _stdout_file = io.open("/dev/stdout", "w")
    except e
      _stdout_failed = true
      _stdout_file = nil
  return _stdout_file

fn _term_write(s)
  if type(s) != "string"
    s = str(s)
  f = _stdout()
  if f != nil
    f.write(s)
    return true
  print s
  return false

fn _repeat_char(ch, n)
  if n <= 0 return ""
  out = ""
  i = 1
  while i <= n
    out = out + ch
    i = i + 1
  return out

fn _pad_right(text, target)
  if #text >= target return text
  return text + _repeat_char(" ", target - #text)

fn coerce_arg(raw, p)
  t = p.type
  if t == nil or t == "any"
    return raw
  if t == "table"
    error("CLI does not support table parameter parsing yet")

  type_def = types.from_hint(t)
  if type_def == nil
    return raw
  return types.coerce(type_def, raw)

fn usage_for(name, cmd)
  parts = {}
  parts[#parts + 1] = name + " " + cmd.name
  for p in cmd.sig.params
    label = p.name == nil ? ("arg" + str(p.index)) : p.name
    if p.variadic
      parts[#parts + 1] = "[" + label + " ...]"
    elif p.has_default
      parts[#parts + 1] = "[" + label + "]"
    else
      parts[#parts + 1] = "<" + label + ">"
  return table.concat(parts, " ")

App = {}
App.__index = App

fn app_new(cls, opts = nil)
  if type(opts) != "table"
    opts = {}
  app = {
    name = opts.name == nil ? "app" : opts.name,
    commands = {},
    order = {}
  }
  setmetatable(app, App)
  return app

AppMeta = {}
AppMeta.__call = app_new
setmetatable(App, AppMeta)

fn register_command(self, name, fn_)
  sig = inspect.signature(fn_)
  cmd = {
    name = name,
    fn_ = fn_,
    sig = sig
  }
  self.commands[name] = cmd
  self.order[#self.order + 1] = name

fn command(self, name = nil)
  if type(name) == "function"
    sig = inspect.signature(name)
    cmd_name = sig.name == nil ? "cmd" : sig.name
    register_command(self, cmd_name, name)
    return name

  return fn(fn_)
    sig = inspect.signature(fn_)
    cmd_name = name
    if cmd_name == nil
      cmd_name = sig.name == nil ? "cmd" : sig.name
    register_command(self, cmd_name, fn_)
    return fn_
App.command = command

fn help(self)
  lines = {}
  lines[#lines + 1] = "Usage: " + self.name + " <command> [args]"
  lines[#lines + 1] = "Commands:"
  for name in self.order
    cmd = self.commands[name]
    lines[#lines + 1] = "  " + usage_for(self.name, cmd)
  return table.concat(lines, "\n")
App.help = help

fn build_args(cmd, raw_args)
  params = cmd.sig.params
  args = {}
  param_count = #params

  variadic = false
  required = 0
  if param_count > 0 and params[param_count].variadic
    variadic = true

  for i, p in params
    if p.variadic
      break
    if not p.has_default
      required = required + 1

  min_needed = required
  max_allowed = variadic ? nil : param_count

  if #raw_args < min_needed
    error("Not enough arguments for '" + cmd.name + "'")
  if max_allowed != nil and #raw_args > max_allowed
    error("Too many arguments for '" + cmd.name + "'")

  fixed_count = variadic ? (param_count - 1) : param_count

  i = 1
  while i <= fixed_count
    p = params[i]
    if i <= #raw_args
      args[#args + 1] = coerce_arg(raw_args[i], p)
    elif p.has_default
      -- Omit trailing defaults; function call will apply defaults.
      break
    else
      error("Missing required argument '" + p.name + "'")
    i = i + 1

  if variadic
    j = fixed_count + 1
    while j <= #raw_args
      args[#args + 1] = raw_args[j]
      j = j + 1

  return args

fn run(self, argv = nil)
  args = argv
  if args == nil
    args = os.argv

  if args == nil or #args == 0
    printc(self.help())
    return nil

  cmd_name = args[1]
  if cmd_name == "-h" or cmd_name == "--help"
    printc(self.help())
    return nil

  cmd = self.commands[cmd_name]
  if cmd == nil
    error("Unknown command: " + str(cmd_name))

  raw = {}
  for i in 2..#args
    raw[#raw + 1] = args[i]

  parsed = build_args(cmd, raw)
  return cmd.fn_(*parsed)
App.run = run

Status = {}
Status.__index = Status

fn status_new(msg = "working", opts = nil)
  if type(opts) != "table"
    opts = {}
  frames = opts.frames
  if type(frames) != "table" or #frames == 0
    frames = {"|", "/", "-", "\\"}
  s = {
    message = msg,
    frames = frames,
    frame_index = 1,
    active = false,
    last_len = 0,
    auto_handle = nil,
    auto_stop = nil,
    auto = opts.auto == nil ? false : bool(opts.auto),
    interval = opts.interval == nil ? 0.08 : opts.interval
  }
  setmetatable(s, Status)
  return s

fn _status_auto_loop(st, stop_ch, interval)
  while true
    local item, ok = stop_ch.tryrecv(stop_ch)
    if ok
      return true
    st.tick()
    thread.sleep(interval)

Status.line = fn(self)
  frame = self.frames[self.frame_index]
  if frame == nil
    frame = self.frames[1]
  return "[cyan]" + frame + "[/] " + self.message

Status.start = fn(self, msg = nil)
  if msg != nil
    self.message = msg
  self.active = true
  return self

Status.start_auto = fn(self, interval = 0.08, msg = nil)
  if msg != nil
    self.message = msg
  self.active = true
  if thread == nil
    return false
  if self.auto_handle != nil
    return true

  if interval == nil or interval <= 0
    interval = 0.08
  self.auto_stop = thread.channel(1)
  local h, err = thread.spawn(_status_auto_loop, self, self.auto_stop, interval)
  if h == nil
    self.auto_stop = nil
    return false
  self.auto_handle = h
  return true

Status.__enter = fn(self)
  if self.auto
    self.start_auto(self.interval)
  else
    self.start()
  return self

Status.tick = fn(self, msg = nil)
  if not self.active
    self.start()
  if msg != nil
    self.message = msg

  raw = self.line()
  formatted = _format(raw)
  out = "\r" + _pad_right(formatted, self.last_len)
  self.last_len = #formatted
  _term_write(out)

  self.frame_index = self.frame_index + 1
  if self.frame_index > #self.frames
    self.frame_index = 1
  return self

Status.stop = fn(self, msg = nil, ok = true)
  if self.auto_handle != nil and self.auto_stop != nil
    self.auto_stop.send(self.auto_stop, true)
    thread.join(self.auto_handle)
    self.auto_handle = nil
    self.auto_stop = nil
  if msg != nil
    self.message = msg
  final = ok ? "[green]ok[/] " : "[red]x[/] "
  formatted = _format(final + self.message)
  out = "\r" + _pad_right(formatted, self.last_len) + "\n"
  _term_write(out)
  self.active = false
  self.last_len = 0
  return self

Status.__exit = fn(self, ex)
  if ex == nil
    self.stop(self.message, true)
  else
    self.stop(self.message, false)

Progress = {}
Progress.__index = Progress

fn progress_new(total = 100, opts = nil)
  if type(opts) != "table"
    opts = {}

  if total == nil or total <= 0
    total = 1

  p = {
    total = int(total),
    value = 0,
    width = opts.width == nil ? 30 : int(opts.width),
    prefix = opts.prefix == nil ? "" : str(opts.prefix),
    suffix = opts.suffix == nil ? "" : str(opts.suffix),
    complete = opts.complete == nil ? "=" : str(opts.complete),
    incomplete = opts.incomplete == nil ? "-" : str(opts.incomplete),
    show_counts = opts.show_counts == nil ? true : bool(opts.show_counts),
    last_len = 0
  }
  if p.width < 5
    p.width = 5

  setmetatable(p, Progress)
  return p

Progress.line = fn(self)
  v = self.value
  if v < 0
    v = 0
  if v > self.total
    v = self.total

  ratio = self.total > 0 ? (v / self.total) : 1
  filled = int(ratio * self.width)
  if filled < 0
    filled = 0
  if filled > self.width
    filled = self.width

  bar = _repeat_char(self.complete, filled) + _repeat_char(self.incomplete, self.width - filled)
  pct = int(ratio * 100)

  left = self.prefix
  if #left > 0
    left = left + " "
  right = self.suffix
  if #right > 0
    right = " " + right

  counts = ""
  if self.show_counts
    counts = " (" + str(v) + "/" + str(self.total) + ")"

  return left + "[" + bar + "] " + str(pct) + "%" + counts + right

Progress.render = fn(self)
  formatted = _format(self.line())
  out = "\r" + _pad_right(formatted, self.last_len)
  self.last_len = #formatted
  _term_write(out)
  return self

Progress.update = fn(self, value, suffix = nil)
  self.value = int(value)
  if suffix != nil
    self.suffix = str(suffix)
  return self.render()

Progress.advance = fn(self, delta = 1)
  self.value = self.value + int(delta)
  return self.render()

Progress.finish = fn(self, suffix = nil)
  self.value = self.total
  if suffix != nil
    self.suffix = str(suffix)
  self.render()
  _term_write("\n")
  self.last_len = 0
  return self

Progress.__enter = fn(self)
  self.render()
  return self

Progress.__exit = fn(self, ex)
  if ex == nil
    self.finish(self.suffix)
  else
    self.finish("failed")

return {
  App = App,
  _format = _format,
  printc = printc,
  status = status_new,
  progress = progress_new
}
