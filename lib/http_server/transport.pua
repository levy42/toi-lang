string = import string
table = import table
socket = import socket
http = import http
coroutine = import coroutine
os = import os
selector = import lib.selector

thread = nil
try
  thread = import thread
except e
  thread = nil

Transport = {}

fn set_nonblocking(sock)
  sock.settimeout(sock, 0)

fn find_connection_index(connections, sock)
  return table.find_index(connections, sock, fn(c) return c.sock)

fn close_connection(conn)
  if conn.sock
    conn.sock.close(conn.sock)
  conn.sock = nil
  conn.coro = nil

fn update_connection_state(server, conn, mode)
  status = coroutine.status(conn.coro)
  match status
    case "dead"
      conn.mode = "dead"
      server.request_count = server.request_count + 1
    else
      conn.mode = mode or "read"

fn handle_connection(server, client)
  local data, err = client.recv(client, 4096)

  while data == nil
    if err and (err == "timeout" or string.find(err, "timeout"))
      client = coroutine.yield("read")
      local d, e = client.recv(client, 4096)
      data = d
      err = e
    else
      break

  try
    if data and string.len(data) > 0
      req = http.parse(data)
      if req
        res = server.handler(req)
        client.send(client, server.normalize_response(res))
      else
        client.send(client, http.response(400, nil, "Bad Request"))
  except e
    client.send(client, http.response(500, nil, "Internal Server Error"))
  finally
    client.close(client)
  return "done"

fn start_connection(server, client)
  co = coroutine.create(handle_connection)
  conn = {sock = client, coro = co, mode = "read"}
  local ok, mode = coroutine.resume(co, server, client)
  update_connection_state(server, conn, mode)
  return conn

fn compact_connections(connections)
  active = {}
  for conn in connections
    if conn.mode != "dead"
      table.insert(active, conn)
    else
      close_connection(conn)
  return active

fn run_maintenance(server, active_connections, last_gc_req, last_log_req)
  if server.gc_every_requests and server.gc_every_requests > 0
    if server.request_count > 0 and server.request_count % server.gc_every_requests == 0 and server.request_count != last_gc_req
      gc
      last_gc_req = server.request_count
      if server.trim_after_gc and os.trim
        os.trim()

  if server.log_every_requests and server.log_every_requests > 0
    if server.request_count > 0 and server.request_count % server.log_every_requests == 0 and server.request_count != last_log_req
      rss = -1
      if os.rss
        r = os.rss()
        if r != nil
          rss = int(r)
      print string.format("http_server stats: req=%d conn=%d mem=%d rss=%d", server.request_count, active_connections, int(mem()), rss)
      last_log_req = server.request_count

  return {["gc"] = last_gc_req, ["log"] = last_log_req}

fn run_coroutine_loop(server)
  connections = {}
  sel = selector.new()
  last_gc_req = 0
  last_log_req = 0

  while true
    selector.clear(sel)
    selector.add_read(sel, server.socket)
    for conn in connections
      if conn.mode == "read"
        selector.add_read(sel, conn.sock)

    local ready_read, ready_write = selector.wait(sel, 0.1)

    if ready_read
      for sock in ready_read
        if sock == server.socket
          local client, ip = server.socket.accept(server.socket)
          if client
            set_nonblocking(client)
            conn = start_connection(server, client)
            if conn.mode != "dead"
              table.insert(connections, conn)
            else
              close_connection(conn)
        else
          idx = find_connection_index(connections, sock)
          if idx > 0
            conn = connections[idx]
            local ok, mode = coroutine.resume(conn.coro, conn.sock)
            update_connection_state(server, conn, mode)

    connections = compact_connections(connections)
    maint = run_maintenance(server, #connections, last_gc_req, last_log_req)
    last_gc_req = maint["gc"]
    last_log_req = maint["log"]

fn run_worker_loop(server, queue, select_timeout)
  connections = {}
  sel = selector.new()

  while true
    got_new = false
    while true
      local item, ok = queue.tryrecv(queue)
      if not ok
        break
      got_new = true
      if item == "__stop__"
        for conn in connections
          close_connection(conn)
        return "stopped"

      conn = start_connection(server, item)
      if conn.mode != "dead"
        table.insert(connections, conn)
      else
        close_connection(conn)

    if #connections == 0 and not got_new
      item = queue.recv(queue)
      if item == nil or item == "__stop__"
        return "stopped"
      conn = start_connection(server, item)
      if conn.mode != "dead"
        table.insert(connections, conn)
      else
        close_connection(conn)

    selector.clear(sel)
    for conn in connections
      if conn.mode == "read"
        selector.add_read(sel, conn.sock)

    if selector.read_count(sel) > 0
      local ready_read, ready_write = selector.wait(sel, select_timeout)
      if ready_read
        for sock in ready_read
          idx = find_connection_index(connections, sock)
          if idx > 0
            conn = connections[idx]
            local ok, mode = coroutine.resume(conn.coro, conn.sock)
            update_connection_state(server, conn, mode)
    else
      thread.sleep(select_timeout)

    connections = compact_connections(connections)
    thread.yield()

fn run_threaded_loop(server)
  worker_count = int(server.worker_threads)
  if worker_count < 1
    return run_coroutine_loop(server)
  if thread == nil
    print "thread module unavailable; using coroutine loop"
    return run_coroutine_loop(server)

  queues = {}
  workers = {}
  i = 1
  while i <= worker_count
    q = thread.channel(server.worker_queue_capacity)
    queues[i] = q
    workers[i] = thread.spawn(run_worker_loop, server, q, server.worker_select_timeout)
    i = i + 1

  next_worker = 1
  last_gc_req = 0
  last_log_req = 0
  accept_selector = selector.new()

  while true
    selector.clear(accept_selector)
    selector.add_read(accept_selector, server.socket)
    local ready_read, ready_write = selector.wait(accept_selector, 0.1)
    if ready_read and #ready_read > 0
      local client, ip = server.socket.accept(server.socket)
      if client
        set_nonblocking(client)
        target = queues[next_worker]
        next_worker = next_worker + 1
        if next_worker > worker_count
          next_worker = 1
        ok = target.send(target, client)
        if not ok
          client.close(client)

    maint = run_maintenance(server, worker_count, last_gc_req, last_log_req)
    last_gc_req = maint["gc"]
    last_log_req = maint["log"]
    thread.yield()

Transport.run = fn(self, server_override = nil)
  server = server_override or self
  server.socket.bind(server.socket, server.host, server.port)
  server.socket.listen(server.socket, 128)
  set_nonblocking(server.socket)

  print("HTTP Server running on " + server.host + ":" + str(server.port))

  if server.worker_threads and server.worker_threads > 0
    return run_threaded_loop(server)
  return run_coroutine_loop(server)

return Transport
