cli = import cli
socket = import socket
string = import string
os = import os
table = import table

thread = nil
try
  thread = import thread
except e
  thread = nil

fn parse_url(raw_url)
  if type(raw_url) != "string" or raw_url == ""
    error("url must be a non-empty string")

  url = string.trim(raw_url)
  scheme = "http"
  rest = url

  local si, sj = string.find(url, "://")
  if si
    scheme = string.lower(string.sub(url, 1, si - 1))
    rest = string.sub(url, sj + 1)

  if scheme != "http" and scheme != "https"
    error("unsupported scheme: " + scheme + " (use http or https)")

  local slash_i, slash_j = string.find(rest, "/")
  hostport = rest
  path = "/"
  if slash_i
    hostport = string.sub(rest, 1, slash_i - 1)
    path = string.sub(rest, slash_i)
    if path == ""
      path = "/"

  host = hostport
  port = (scheme == "https") ? 443 : 80

  local colon_i, colon_j = string.find(hostport, ":")
  if colon_i and colon_i > 1
    host = string.sub(hostport, 1, colon_i - 1)
    raw_port = string.sub(hostport, colon_j + 1)
    try
      port = int(raw_port)
    except e
      error("invalid port in URL: " + raw_port)

  if host == ""
    error("URL host is empty")
  if port <= 0 or port > 65535
    error("URL port out of range: " + str(port))

  return {
    scheme = scheme,
    host = host,
    port = port,
    path = path
  }

fn build_request(method, target, host)
  m = string.upper(method or "GET")
  t = target == nil or target == "" ? "/" : target
  lines = {}
  lines <+ f"{m} {t} HTTP/1.1"
  lines <+ f"Host: {host}"
  lines <+ "Connection: close"
  lines <+ "User-Agent: toi-loadtest/0.1"
  lines <+ "Accept: */*"
  lines <+ ""
  lines <+ ""
  return table.concat(lines, "\r\n")

fn parse_status_code(response)
  if response == nil or response == ""
    return nil
  local line_end_i, line_end_j = string.find(response, "\r\n")
  if not line_end_i
    return nil
  status_line = string.sub(response, 1, line_end_i - 1)
  parts = string.split(status_line, " ")
  if #parts < 2
    return nil
  try
    return int(parts[2])
  except e
    return nil

fn run_one(request, cfg)
  client = socket.tcp()
  if client == nil
    return false, nil, 0, "tcp() failed"

  client.settimeout(client, cfg.timeout_sec)

  local conn_ok, conn_err = client.connect(client, cfg.host, cfg.port)
  if not conn_ok
    client.close(client)
    return false, nil, 0, conn_err or conn_ok or "connect failed"

  if cfg.scheme == "https"
    local tls_ok, tls_err = client.tls(client, cfg.host, cfg.verify_tls)
    if not tls_ok
      client.close(client)
      return false, nil, 0, tls_err or tls_ok or "tls failed"

  local sent, send_err = client.send(client, request)
  if type(sent) != "number"
    client.close(client)
    return false, nil, 0, send_err or sent or "send failed"

  chunks = {}
  saw_data = false
  while true
    local chunk, recv_err = client.recv(client, 4096)
    if chunk == nil
      if recv_err == "timeout"
        if saw_data
          break
        client.close(client)
        return false, nil, 0, "timeout"
      if recv_err == nil
        break
      msg = string.lower(str(recv_err))
      if msg.find("closed") or msg.find("reset")
        break
      if saw_data
        break
      client.close(client)
      return false, nil, 0, recv_err

    if chunk == ""
      break

    saw_data = true
    chunks <+ chunk

  client.close(client)

  response = table.concat(chunks, "")
  code = parse_status_code(response)
  if code == nil
    return false, nil, #response, "invalid http response"

  return true, code, #response, nil

fn worker_loop(cfg)
  stats = {
    attempts = 0,
    responses = 0,
    ok = 0,
    fail = 0,
    bytes = 0
  }

  req = build_request(cfg.method, cfg.path, cfg.host)
  deadline = os.clock() + cfg.duration_sec
  while os.clock() < deadline
    stats.attempts = stats.attempts + 1
    local ok, code, nbytes, err = run_one(req, cfg)
    if ok
      stats.responses = stats.responses + 1
      stats.bytes = stats.bytes + nbytes
      if code >= 200 and code < 400
        stats.ok = stats.ok + 1
      else
        stats.fail = stats.fail + 1
    else
      stats.fail = stats.fail + 1

  return stats

fn merge_stats(dst, src)
  dst.attempts = (dst.attempts or 0) + (src.attempts or 0)
  dst.responses = (dst.responses or 0) + (src.responses or 0)
  dst.ok = (dst.ok or 0) + (src.ok or 0)
  dst.fail = (dst.fail or 0) + (src.fail or 0)
  dst.bytes = (dst.bytes or 0) + (src.bytes or 0)
  return dst

fn worker_entry(cfg, ch)
  ch.send(ch, worker_loop(cfg))
  return true

app = cli.App(name = "loadtest")

@app.command
fn rps(url, duration_sec: int = 10, concurrency: int = 10, timeout_ms: int = 2000, verify_tls: bool = false)
  parsed = parse_url(url)

  d = duration_sec
  if d < 1
    d = 1
  c = concurrency
  if c < 1
    c = 1
  if thread == nil and c > 1
    cli.printc("[yellow]thread module unavailable; forcing concurrency=1[/]")
    c = 1
  t_ms = timeout_ms
  if t_ms < 1
    t_ms = 1

  cfg = {
    scheme = parsed.scheme,
    host = parsed.host,
    port = parsed.port,
    path = parsed.path,
    method = "GET",
    duration_sec = d,
    timeout_sec = t_ms / 1000.0,
    verify_tls = verify_tls
  }

  cli.printc(string.format("[cyan]target[/] %s://%s:%d%s  [cyan]duration[/] %ds  [cyan]concurrency[/] %d", cfg.scheme, cfg.host, cfg.port, cfg.path, d, c))

  started = os.clock()
  total = {attempts = 0, responses = 0, ok = 0, fail = 0, bytes = 0}

  if c == 1
    total = merge_stats(total, worker_loop(cfg))
  else
    ch = thread.channel(c)
    handles = {}
    for i in 1..c
      handles <+ thread.spawn(worker_entry, cfg, ch)

    for i in 1..c
      worker_stats = ch.recv(ch)
      if type(worker_stats) == "table"
        total = merge_stats(total, worker_stats)

    for h in handles
      thread.join(h)

  elapsed = os.clock() - started
  if elapsed <= 0
    elapsed = 0.000001

  rps = total.responses / elapsed
  ok_rps = total.ok / elapsed
  mbps = (total.bytes / (1024.0 * 1024.0)) / elapsed

  print ""
  print "Summary"
  print "  requests:    " + str(total.responses) + " responses (" + str(total.attempts) + " attempts)"
  print "  ok/fail:     " + str(total.ok) + " / " + str(total.fail)
  print "  elapsed:     " + string.format("%.3fs", elapsed)
  print "  rps:         " + string.format("%.2f", rps)
  print "  ok rps:      " + string.format("%.2f", ok_rps)
  print "  throughput:  " + string.format("%.2f MiB/s", mbps)
  return {
    requests = total.responses,
    attempts = total.attempts,
    ok = total.ok,
    fail = total.fail,
    elapsed = elapsed,
    rps = rps,
    ok_rps = ok_rps,
    mbps = mbps
  }

LoadTest = {
  app = app,
  parse_url = parse_url,
  build_request = build_request,
  parse_status_code = parse_status_code
}

if os.argv and #os.argv > 0
  app.run()

return LoadTest
