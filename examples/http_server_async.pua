-- Async HTTP server using socket.select()
-- Non-blocking I/O for handling multiple connections

local string = import string
local table = import table
local socket = import socket
local json = import json
local http = import http

local PORT = 8080

-- Request handler
fn handle_request(req)
    if req.path == "/"
        local h = {}
        h["Content-Type"] = "text/html"
        return http.response(200, h, "<h1>Async Pua Server</h1>")
    elif req.path == "/hello"
        local params = http.parsequery(req.query or "")
        local name = params.name or "Guest"
        local h = {}
        h["Content-Type"] = "text/html"
        return http.response(200, h, "<h1>Hello, " + name + "!</h1>")
    elif req.path == "/json"
        local h = {}
        h["Content-Type"] = "application/json"
        return http.response(200, h, json.encode({message = "Hello"}))
    else
        local h = {}
        h["Content-Type"] = "text/plain"
        return http.response(404, h, "Not Found")

-- Client tracking
local clients = {}

fn add_client(sock)
    sock.settimeout(sock, 0)
    table.insert(clients, {sock = sock, buf = ""})

fn remove_client(i)
    clients[i].sock.close(clients[i].sock)
    table.remove(clients, i)

-- Setup server
local server = socket.tcp()
server.bind(server, "0.0.0.0", PORT)
server.listen(server, 128)
server.settimeout(server, 0)

print("Async server on http://localhost:" + str(PORT))

-- Event loop
while true
    -- Build read list: server + all clients
    local reads = {server}
    for i = 1, #clients
        table.insert(reads, clients[i].sock)

    -- Wait for activity (100ms timeout)
    local ready, w = socket.select(reads, {}, 0.1)

    -- Check for new connections
    for i = 1, #ready
        if ready[i] == server
            local cli, ip = server.accept(server)
            if cli
                add_client(cli)

    -- Process clients
    local i = 1
    while i <= #clients
        local c = clients[i]
        local data = c.sock.recv(c.sock, 4096)

        if data and string.len(data) > 0
            c.buf = c.buf + data
            if string.find(c.buf, "\r\n\r\n")
                local req = http.parse(c.buf)
                if req
                    local resp = handle_request(req)
                    c.sock.send(c.sock, resp)
                remove_client(i)
            else
                i = i + 1
        else
            i = i + 1
