-- Concurrent HTTP server using coroutines
-- Each connection runs in its own coroutine

local string = import string
local table = import table
local socket = import socket
local thread = import thread
local json = import json
local os = import os
local http = import http
local coroutine = import coroutine

local PORT = 8080

-- Request handler
fn handle_request(req)
    if req.path == "/"
        local headers = {}
        headers["Content-Type"] = "text/html"
        return http.response(200, headers, "<h1>Welcome to Pua!</h1><p>Concurrent server with coroutines</p>")
    elif req.path == "/hello"
        local params = http.parsequery(req.query or "")
        local name = params.name or "Guest"
        local headers = {}
        headers["Content-Type"] = "text/html"
        return http.response(200, headers, "<h1>Hello, " + name + "!</h1>")
    elif req.path == "/json"
        local headers = {}
        headers["Content-Type"] = "application/json"
        local data = {message = "Hello from Pua", timestamp = os.clock()}
        return http.response(200, headers, json.encode(data))
    elif req.path == "/slow"
        -- Simulate slow request (would not block other connections)
        local headers = {}
        headers["Content-Type"] = "text/plain"
        return http.response(200, headers, "This was a slow request")
    else
        local headers = {}
        headers["Content-Type"] = "text/plain"
        return http.response(404, headers, "Not Found: " + req.path)

-- Connection handler (runs as coroutine)
fn connection_handler(client)
    local data, err = client.recv(client, 4096)
    
    -- Loop while we get a timeout (would block)
    while data == nil
        -- Check for timeout error (handle potential string equality issues)
        if err and (err == "timeout" or string.find(err, "timeout") or string.len(err) == 7)
            -- Yield back to scheduler, wait for next tick
            client = coroutine.yield()
            local d, e = client.recv(client, 4096)
            data = d
            err = e
        else
            break
    
    if data and string.len(data) > 0
        local req = http.parse(data)
        if req
            local response = handle_request(req)
            client.send(client, response)
    client.close(client)
    return "done"

-- Simple coroutine scheduler
local connections = {}  -- list of {coro, client}
local next_id = 1

fn add_connection(client)
    local coro = coroutine.create(connection_handler)
    table.insert(connections, {id = next_id, coro = coro, client = client})
    next_id = next_id + 1

fn run_scheduler()
    local i = 1
    while i <= #connections
        local conn = connections[i]
        local status = coroutine.status(conn.coro)

        if status == "suspended"
            -- Resume coroutine
            local ok = coroutine.resume(conn.coro, conn.client)
            status = coroutine.status(conn.coro)

        if status == "dead"
            -- Remove completed connection
            table.remove(connections, i)
        else
            i = i + 1

-- Main server
print("Starting concurrent HTTP server on port " + str(PORT))

local server = socket.tcp()
server.bind(server, "0.0.0.0", PORT)
server.listen(server, 128)

-- Set server to non-blocking for accept
server.settimeout(server, 0)

print("Listening on http://localhost:" + str(PORT))

local running = true
while running
    -- Try to accept new connection (non-blocking)
    local client = server.accept(server)
    if client
        -- Set client to non-blocking too
        client.settimeout(client, 0)
        add_connection(client)

    -- Run one iteration of scheduler
    run_scheduler()

    -- Small sleep to avoid busy loop when idle
    if #connections == 0 and not client
        thread.sleep(1)  -- 1ms sleep
